'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var React = _interopRequireWildcard(_react);

var _Animate = require('./Animate.web');

var _reactHammerjs = require('react-hammerjs');

var _reactHammerjs2 = _interopRequireDefault(_reactHammerjs);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _utils = require('./utils.web');

var _isChildrenEqual = require('./isChildrenEqual');

var _isChildrenEqual2 = _interopRequireDefault(_isChildrenEqual);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*
 * Based on Zynga Scroller (http://github.com/zynga/scroller)
 * Copyright 2011, Zynga Inc.
 * Licensed under the MIT License.
 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
 */
var DECELERATION_VELOCITY_RATE = 0.95;
// How much velocity is required to keep the deceleration running
var MIN_VELOCITY_TO_KEEP_DECELERATING = 0.5;
var POSITION_MAX_LENGTH = 40;
var DEFAULT_ANIM_DURATION = 250;
var TIME_FRAME = 100;
// How much velocity is required to start the deceleration
var MIN_VELOCITY_TO_START_DECELERATION = 4;
var hammerOption = {
    recognizers: {
        pan: {
            threshold: 5
        }
    }
};
var HAMMER_DOWN = 16;

var Picker = function (_React$Component) {
    (0, _inherits3["default"])(Picker, _React$Component);

    function Picker(props) {
        (0, _classCallCheck3["default"])(this, Picker);

        var _this = (0, _possibleConstructorReturn3["default"])(this, _React$Component.call(this, props));

        _this.onPanStart = function (e) {
            if (e.target.tagName.match(/input|textarea|select/i)) {
                return;
            }
            e.preventDefault();
            _this.clearAnim();
            _this.lastTouchMove = Date.now();
            _this.isTracking = true;
            _this.didDecelerationComplete = false;
            _this.positions = [];
            _this.startScrollTop = _this.scrollTop;
        };
        _this.onPan = function (e) {
            // Ignore event when tracking is not enabled (event might be outside of element)
            if (!_this.isTracking) {
                return;
            }
            var timeStamp = Date.now();
            _this.lastTouchMove = timeStamp;
            var positions = _this.positions;
            var scrollTop = _this.startScrollTop + (e.offsetDirection === HAMMER_DOWN ? -e.distance : e.distance);
            var minScrollTop = _this.minScrollTop;
            var maxScrollTop = _this.maxScrollTop;
            if (scrollTop > maxScrollTop || scrollTop < minScrollTop) {
                // Slow down on the edges
                if (scrollTop > maxScrollTop) {
                    scrollTop = maxScrollTop;
                } else {
                    scrollTop = minScrollTop;
                }
            }
            // Keep list from growing infinitely (holding min 10, max 20 measure points)
            if (positions.length > POSITION_MAX_LENGTH) {
                positions.splice(0, POSITION_MAX_LENGTH / 2);
            }
            // Track scroll movement for declaration
            positions.push(scrollTop, timeStamp);
            // Sync scroll position
            _this.publish(scrollTop);
            // Otherwise figure out whether we are switching into dragging mode now.
        };
        _this.onPanEnd = function () {
            // Ignore event when tracking is not enabled (no touchstart event on element)
            // This is required as this listener ('touchmove')
            // sits on the document and not on the element itself.
            if (!_this.isTracking) {
                return;
            }
            var timeStamp = Date.now();
            // Not touching anymore (when two finger hit the screen there are two touch end events)
            _this.isTracking = false;
            // Be sure to reset the dragging flag now. Here we also detect whether
            // the finger has moved fast enough to switch into a deceleration animation.
            // Start deceleration
            // Verify that the last move detected was in some relevant time frame
            if (timeStamp - _this.lastTouchMove <= TIME_FRAME) {
                // Then figure out what the scroll position was about 100ms ago
                var positions = _this.positions;
                var endPos = positions.length - 1;
                var startPos = endPos;
                // Move pointer to position measured 100ms ago
                for (var i = endPos; i > 0 && positions[i] > _this.lastTouchMove - TIME_FRAME; i -= 2) {
                    startPos = i;
                }
                // If start and stop position is identical in a 100ms timeframe,
                // we cannot compute any useful deceleration.
                if (startPos !== endPos) {
                    // Compute relative movement between these two points
                    var timeOffset = positions[endPos] - positions[startPos];
                    var movedTop = _this.scrollTop - positions[startPos - 1];
                    // Based on 50ms compute the movement to apply for each render step
                    _this.decelerationVelocityY = movedTop / timeOffset * (1000 / 60);
                    // Verify that we have enough velocity to start deceleration
                    if (Math.abs(_this.decelerationVelocityY) > MIN_VELOCITY_TO_START_DECELERATION) {
                        _this.startDeceleration();
                    }
                }
            }
            if (!_this.isDecelerating) {
                _this.scrollTo(_this.scrollTop);
            }
            // Fully cleanup list
            _this.positions.length = 0;
        };
        var selectedValueState = void 0;
        var selectedValue = props.selectedValue;
        var defaultSelectedValue = props.defaultSelectedValue;
        var children = props.children;

        if (selectedValue !== undefined) {
            selectedValueState = selectedValue;
        } else if (defaultSelectedValue !== undefined) {
            selectedValueState = defaultSelectedValue;
        } else if (children.length) {
            selectedValueState = children[0].value;
        }
        _this.state = {
            selectedValue: selectedValueState
        };
        return _this;
    }

    Picker.prototype.componentDidMount = function componentDidMount() {
        (0, _objectAssign2["default"])(this, {
            isTracking: false,
            didDecelerationComplete: false,
            isDecelerating: false,
            isAnimating: false,
            clientHeight: 0,
            contentHeight: 0,
            itemHeight: 0,
            scrollTop: 0,
            minScrollTop: 0,
            maxScrollTop: 0,
            scheduledTop: 0,
            positions: [],
            minDecelerationScrollTop: 0,
            maxDecelerationScrollTop: 0,
            decelerationVelocityY: 0
        });
        var _refs = this.refs;
        var indicator = _refs.indicator;
        var component = _refs.component;
        var content = _refs.content;

        this.itemHeight = parseInt((0, _utils.getComputedStyle)(indicator, 'height'), 10);
        this.setDimensions(component.clientHeight, content.offsetHeight);
        this.select(this.state.selectedValue, false);
    };

    Picker.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('selectedValue' in nextProps) {
            this.setState({
                selectedValue: nextProps.selectedValue
            });
        }
    };

    Picker.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
        return this.state.selectedValue !== nextState.selectedValue || !(0, _isChildrenEqual2["default"])(this.props.children, nextProps.children, this.props.pure);
    };

    Picker.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (!(0, _isChildrenEqual2["default"])(prevProps.children, this.props.children, this.props.pure)) {
            this.componentDidMount();
        } else {
            this.select(this.state.selectedValue, false);
        }
    };

    Picker.prototype.componentWillUnmount = function componentWillUnmount() {
        this.clearAnim();
    };

    Picker.prototype.setTop = function setTop(top) {
        if (this.refs.content) {
            this.refs.content.style.webkitTransform = 'translate3d(0, ' + -top + 'px, 0)';
        }
    };

    Picker.prototype.setDimensions = function setDimensions(clientHeight, contentHeight) {
        this.clientHeight = clientHeight;
        this.contentHeight = contentHeight;
        var totalItemCount = this.props.children.length;
        var clientItemCount = Math.round(this.clientHeight / this.itemHeight);
        this.minScrollTop = -this.itemHeight * (clientItemCount / 2);
        this.maxScrollTop = this.minScrollTop + totalItemCount * this.itemHeight - 0.1;
    };

    Picker.prototype.clearAnim = function clearAnim() {
        if (this.isDecelerating) {
            _Animate.Animate.stop(this.isDecelerating);
            this.isDecelerating = 0;
        }
        if (this.isAnimating) {
            _Animate.Animate.stop(this.isAnimating);
            this.isAnimating = 0;
        }
    };

    Picker.prototype.selectByIndex = function selectByIndex(index, animate) {
        if (index < 0 || index >= this.props.children.length) {
            return;
        }
        this.scrollTop = this.minScrollTop + index * this.itemHeight;
        this.scrollTo(this.scrollTop, animate);
    };

    Picker.prototype.select = function select(value, animate) {
        var children = this.props.children;
        for (var i = 0, len = children.length; i < len; i++) {
            if (children[i].value === value) {
                this.selectByIndex(i, animate);
                return;
            }
        }
        this.selectByIndex(0, animate);
    };

    Picker.prototype.scrollTo = function scrollTo(t, a) {
        var top = t;
        var animate = a;
        animate = animate === undefined ? true : animate;
        this.clearAnim();
        top = Math.round(top / this.itemHeight) * this.itemHeight;
        top = Math.max(Math.min(this.maxScrollTop, top), this.minScrollTop);
        if (top === this.scrollTop || !animate) {
            this.publish(top);
            this.scrollingComplete();
            return;
        }
        this.publish(top, DEFAULT_ANIM_DURATION);
    };

    Picker.prototype.fireValueChange = function fireValueChange(selectedValue) {
        if (selectedValue !== this.state.selectedValue) {
            if (!('selectedValue' in this.props)) {
                this.setState({
                    selectedValue: selectedValue
                });
            }
            this.props.onValueChange(selectedValue);
        }
    };

    Picker.prototype.scrollingComplete = function scrollingComplete() {
        var index = Math.round((this.scrollTop - this.minScrollTop - this.itemHeight / 2) / this.itemHeight);
        var child = this.props.children[index];
        if (child) {
            this.fireValueChange(child.value);
        }
    };
    // Applies the scroll position to the content element


    Picker.prototype.publish = function publish(top, animationDuration) {
        var _this2 = this;

        // Remember whether we had an animation,
        // then we try to continue based on the current "drive" of the animation
        var wasAnimating = this.isAnimating;
        if (wasAnimating) {
            _Animate.Animate.stop(wasAnimating);
            this.isAnimating = 0;
        }
        if (animationDuration) {
            (function () {
                // Keep scheduled positions for scrollBy functionality
                _this2.scheduledTop = top;
                var oldTop = _this2.scrollTop;
                var diffTop = top - oldTop;
                var step = function step(percent) {
                    _this2.scrollTop = oldTop + diffTop * percent;
                    // Push values out
                    _this2.setTop(_this2.scrollTop);
                };
                var verify = function verify(id) {
                    return _this2.isAnimating === id;
                };
                var completed = function completed(renderedFramesPerSecond, animationId, wasFinished) {
                    if (animationId === _this2.isAnimating) {
                        _this2.isAnimating = 0;
                    }
                    if (_this2.didDecelerationComplete || wasFinished) {
                        _this2.scrollingComplete();
                    }
                };
                // When continuing based on previous animation
                // we choose an ease-out animation instead of ease-in-out
                _this2.isAnimating = _Animate.Animate.start(step, verify, completed, animationDuration, wasAnimating ? _Animate.easeOutCubic : _Animate.easeInOutCubic);
            })();
        } else {
            this.scheduledTop = this.scrollTop = top;
            // Push values out
            this.setTop(top);
        }
    };
    // Called when a touch sequence end and the speed of
    // the finger was high enough to switch into deceleration mode.


    Picker.prototype.startDeceleration = function startDeceleration() {
        var _this3 = this;

        this.minDecelerationScrollTop = this.minScrollTop;
        this.maxDecelerationScrollTop = this.maxScrollTop;
        // Wrap class method
        var step = function step(percent, now, render) {
            _this3.stepThroughDeceleration();
        };
        // Detect whether it's still worth to continue animating steps
        // If we are already slow enough to not being user perceivable anymore,
        // we stop the whole process here.
        var verify = function verify() {
            var shouldContinue = Math.abs(_this3.decelerationVelocityY) >= MIN_VELOCITY_TO_KEEP_DECELERATING;
            if (!shouldContinue) {
                _this3.didDecelerationComplete = true;
            }
            return shouldContinue;
        };
        var completed = function completed() {
            _this3.isDecelerating = 0;
            if (_this3.scrollTop <= _this3.minScrollTop || _this3.scrollTop >= _this3.maxScrollTop) {
                _this3.scrollTo(_this3.scrollTop);
                return;
            }
            if (_this3.didDecelerationComplete) {
                _this3.scrollingComplete();
            }
        };
        // Start animation and switch on flag
        this.isDecelerating = _Animate.Animate.start(step, verify, completed);
    };
    // Called on every step of the animation


    Picker.prototype.stepThroughDeceleration = function stepThroughDeceleration() {
        var scrollTop = this.scrollTop + this.decelerationVelocityY;
        var scrollTopFixed = Math.max(Math.min(this.maxDecelerationScrollTop, scrollTop), this.minDecelerationScrollTop);
        if (scrollTopFixed !== scrollTop) {
            scrollTop = scrollTopFixed;
            this.decelerationVelocityY = 0;
        }
        if (Math.abs(this.decelerationVelocityY) <= 1) {
            if (Math.abs(scrollTop % this.itemHeight) < 1) {
                this.decelerationVelocityY = 0;
            }
        } else {
            this.decelerationVelocityY *= DECELERATION_VELOCITY_RATE;
        }
        this.publish(scrollTop);
    };

    Picker.prototype.render = function render() {
        var _props = this.props;
        var children = _props.children;
        var prefixCls = _props.prefixCls;
        var selectedValue = this.state.selectedValue;

        var itemClassName = prefixCls + '-item';
        var selectedItemClassName = itemClassName + ' ' + prefixCls + '-item-selected';
        var items = children.map(function (item) {
            return React.createElement(
                'div',
                { className: selectedValue === item.value ? selectedItemClassName : itemClassName, key: item.value, 'data-value': item.value },
                item.label
            );
        });
        return React.createElement(
            _reactHammerjs2["default"],
            { direction: 'DIRECTION_ALL', onPanStart: this.onPanStart, onPan: this.onPan, onPanEnd: this.onPanEnd, options: hammerOption },
            React.createElement(
                'div',
                { className: '' + prefixCls, 'data-role': 'component', ref: 'component' },
                React.createElement('div', { className: prefixCls + '-mask', 'data-role': 'mask' }),
                React.createElement('div', { className: prefixCls + '-indicator', 'data-role': 'indicator', ref: 'indicator' }),
                React.createElement(
                    'div',
                    { className: prefixCls + '-content', 'data-role': 'content', ref: 'content' },
                    items
                )
            )
        );
    };

    return Picker;
}(React.Component);

exports["default"] = Picker;

Picker.defaultProps = {
    prefixCls: 'rmc-picker',
    pure: true,
    onValueChange: function onValueChange() {}
};
module.exports = exports['default'];