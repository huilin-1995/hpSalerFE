'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _LayoutMixin = require('./Utilties/LayoutMixin');

var _NativeMethodsMixin = require('./Utilties/NativeMethodsMixin');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var View = _react2["default"].createClass({
  displayName: 'View',

  mixins: [_LayoutMixin.Mixin, _NativeMethodsMixin.Mixin],
  propTypes: {
    /**
     * When true, indicates that the view is an accessibility element. By default,
     * all the touchable elements are accessible.
     */
    accessible: _react.PropTypes.bool,

    /**
     * Overrides the text that's read by the screen reader when the user interacts
     * with the element. By default, the label is constructed by traversing all the
     * children and accumulating all the Text nodes separated by space.
     */
    accessibilityLabel: _react.PropTypes.string,
    /**
     * When `accessible` is true, the system will try to invoke this function
     * when the user performs accessibility tap gesture.
     */
    onAccessibilityTap: _react.PropTypes.func,

    /**
     * When `accessible` is true, the system will invoke this function when the
     * user performs the magic tap gesture.
     */
    onMagicTap: _react.PropTypes.func,

    /**
     * Used to locate this view in end-to-end tests. NB: disables the 'layout-only
     * view removal' optimization for this view!
     */
    testID: _react.PropTypes.string,

    /**
     * For most touch interactions, you'll simply want to wrap your component in
     * `TouchableHighlight` or `TouchableOpacity`. Check out `Touchable.js`,
     * `ScrollResponder.js` and `ResponderEventPlugin.js` for more discussion.
     */
    onResponderGrant: _react.PropTypes.func,
    onResponderMove: _react.PropTypes.func,
    onResponderReject: _react.PropTypes.func,
    onResponderRelease: _react.PropTypes.func,
    onResponderTerminate: _react.PropTypes.func,
    onResponderTerminationRequest: _react.PropTypes.func,
    onStartShouldSetResponder: _react.PropTypes.func,
    onStartShouldSetResponderCapture: _react.PropTypes.func,
    onMoveShouldSetResponder: _react.PropTypes.func,
    onMoveShouldSetResponderCapture: _react.PropTypes.func,

    /**
     * Invoked on mount and layout changes with
     *
     *   {nativeEvent: { layout: {x, y, width, height}}}.
     *
     * This event is fired immediately once the layout has been calculated, but
     * the new layout may not yet be reflected on the screen at the time the
     * event is received, especially if a layout animation is in progress.
     */
    onLayout: _react.PropTypes.func,

    /**
     * Controls whether the View can be the target of touch events.
     *
     *   - 'auto': The View can be the target of touch events.
     *   - 'none': The View is never the target of touch events.
     *   - 'box-none': The View is never the target of touch events but it's
     *     subviews can be. It behaves like if the view had the following classes
     *     in CSS:
     * ```
     * .box-none {
     * 		pointer-events: none;
     * }
     * .box-none * {
     * 		pointer-events: all;
     * }
     * ```
     *   - 'box-only': The view can be the target of touch events but it's
     *     subviews cannot be. It behaves like if the view had the following classes
     *     in CSS:
     * ```
     * .box-only {
     * 		pointer-events: all;
     * }
     * .box-only * {
     * 		pointer-events: none;
     * }
     * ```
     */
    // Since `pointerEvents` does not affect layout/appearance, and we are
    // already deviating from the spec by adding additional modes, we opt to not
    // include `pointerEvents` on `style`. On some platforms, we would need to
    // implement it as a `className` anyways. Using `style` or not is an
    // implementation detail of the platform.
    pointerEvents: _react.PropTypes.oneOf(['box-none', 'none', 'box-only', 'auto']),
    style: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.array]),

    /**
     * This is a special performance property exposed by RCTView and is useful
     * for scrolling content when there are many subviews, most of which are
     * offscreen. For this property to be effective, it must be applied to a
     * view that contains many subviews that extend outside its bound. The
     * subviews must also have overflow: hidden, as should the containing view
     * (or one of its superviews).
     */
    removeClippedSubviews: _react.PropTypes.bool
  },
  render: function render() {
    var _props = this.props;
    var children = _props.children;
    var className = _props.className;
    var style = _props.style;
    var onScroll = _props.onScroll;
    var _props$onCick = _props.onCick;
    var onCick = _props$onCick === undefined ? function () {} : _props$onCick;

    var divProps = { className: className, style: style, onScroll: onScroll, onClick: onCick };
    return _react2["default"].createElement(
      'div',
      divProps,
      children
    );
  }
});

View.isReactNativeComponent = true;

exports["default"] = View;
module.exports = exports['default'];